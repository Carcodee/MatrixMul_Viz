<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Matrix Multiplication Demo Visualization</title>
    <style>
      :root {
        --bg-main: #0e1116;
        --bg-main-2: #151a22;
        --bg-surface: rgba(22, 27, 36, 0.9);
        --bg-surface-strong: rgba(18, 23, 31, 0.96);
        --bg-input: #141a23;
        --text-main: #f3f5f8;
        --text-soft: #b4bdca;
        --stroke: rgba(255, 255, 255, 0.12);
        --accent: #cdd8eb;
        --radius: 10px;
      }

      html,
      body {
        margin: 0;
        height: 100%;
        overflow: hidden;
        background:
          radial-gradient(circle at 14% 12%, #232b39 0%, rgba(35, 43, 57, 0) 34%),
          linear-gradient(130deg, var(--bg-main) 0%, var(--bg-main-2) 100%);
        color: var(--text-main);
        font-family: "Segoe UI", "Aptos", Tahoma, Geneva, Verdana, sans-serif;
      }

      #app {
        width: 100%;
        height: 100%;
      }

      .hud {
        position: fixed;
        top: 12px;
        left: 12px;
        z-index: 20;
        max-width: 420px;
        padding: 10px 11px;
        border-radius: var(--radius);
        border: 1px solid var(--stroke);
        background: var(--bg-surface);
        backdrop-filter: blur(6px);
        font-size: 12px;
        line-height: 1.4;
        color: var(--text-soft);
      }

      .controls {
        position: fixed;
        top: 12px;
        right: 12px;
        z-index: 20;
        padding: 9px;
        border-radius: var(--radius);
        border: 1px solid var(--stroke);
        background: var(--bg-surface);
        backdrop-filter: blur(6px);
        display: flex;
        flex-direction: column;
        gap: 7px;
      }

      .control-row {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
      }

      .panel-toggle-row {
        display: flex;
        flex-wrap: wrap;
        gap: 5px;
        max-width: 360px;
      }

      button {
        background: rgba(255, 255, 255, 0.06);
        color: var(--text-main);
        border: 1px solid var(--stroke);
        border-radius: 8px;
        padding: 6px 10px;
        cursor: pointer;
        font-weight: 600;
        transition: border-color 0.15s ease, background 0.15s ease, transform 0.15s ease;
      }

      button:hover {
        border-color: rgba(255, 255, 255, 0.24);
        background: rgba(255, 255, 255, 0.1);
      }

      button:active {
        transform: translateY(1px);
      }

      button:focus-visible,
      .matrix-grid input:focus-visible,
      .matrix-actions input:focus-visible,
      .matrix-actions select:focus-visible {
        outline: 2px solid rgba(220, 233, 255, 0.55);
        outline-offset: 1px;
      }

      .controls span {
        font-size: 13px;
        color: var(--text-soft);
      }

      .panel-toggle {
        border-radius: 999px;
        padding: 4px 9px;
        font-size: 11px;
        letter-spacing: 0.01em;
      }

      .panel-toggle[data-active="true"] {
        background: rgba(220, 233, 255, 0.2);
        border-color: rgba(220, 233, 255, 0.45);
      }

      .panel-toggle[data-active="false"] {
        background: rgba(12, 16, 23, 0.85);
        color: #94a2ba;
        border-color: rgba(255, 255, 255, 0.08);
      }

      .hidden {
        display: none !important;
      }

      .matrix-panel {
        position: fixed;
        right: 12px;
        bottom: 12px;
        width: min(420px, calc(100vw - 24px));
        max-height: calc(100vh - 170px);
        overflow-y: auto;
        padding: 9px;
        border-radius: 12px;
        border: 1px solid var(--stroke);
        background: var(--bg-surface-strong);
        backdrop-filter: blur(8px);
        font-size: 12px;
        z-index: 20;
        box-shadow: 0 8px 26px rgba(0, 0, 0, 0.32);
      }

      .math-panel {
        position: fixed;
        left: 12px;
        bottom: 12px;
        width: min(460px, calc(100vw - 24px));
        max-height: min(46vh, 420px);
        overflow-y: auto;
        padding: 9px;
        border-radius: 12px;
        border: 1px solid var(--stroke);
        background: var(--bg-surface-strong);
        backdrop-filter: blur(8px);
        font-size: 12px;
        z-index: 20;
        box-shadow: 0 8px 26px rgba(0, 0, 0, 0.32);
      }

      .current-state-panel {
        position: fixed;
        left: 12px;
        top: 128px;
        width: min(460px, calc(100vw - 24px));
        max-height: min(38vh, 360px);
        overflow-y: auto;
        padding: 9px;
        border-radius: 12px;
        border: 1px solid var(--stroke);
        background: var(--bg-surface-strong);
        backdrop-filter: blur(8px);
        font-size: 12px;
        z-index: 20;
        box-shadow: 0 8px 26px rgba(0, 0, 0, 0.32);
      }

      .current-state-panel::-webkit-scrollbar {
        width: 8px;
      }

      .current-state-panel::-webkit-scrollbar-thumb {
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.2);
      }

      .math-panel::-webkit-scrollbar {
        width: 8px;
      }

      .math-panel::-webkit-scrollbar-thumb {
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.2);
      }

      .matrix-panel::-webkit-scrollbar {
        width: 8px;
      }

      .matrix-panel::-webkit-scrollbar-thumb {
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.2);
      }

      .panel-section {
        margin-bottom: 8px;
        padding: 9px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 9px;
        background: rgba(255, 255, 255, 0.03);
      }

      .matrix-panel h3 {
        margin: 0 0 8px;
        font-size: 13px;
        font-weight: 600;
        letter-spacing: 0;
      }

      .panel-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
      }

      .panel-subtitle {
        font-size: 11px;
        color: var(--text-soft);
        margin: 0;
      }

      .matrix-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 6px;
      }

      .matrix-col-labels {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 6px;
        margin-bottom: 6px;
      }

      .matrix-col-label {
        text-align: center;
        font-size: 11px;
        font-weight: 700;
        border-radius: 4px;
        padding: 3px 0;
        color: #0b1020;
      }

      .matrix-grid input {
        width: 100%;
        height: 30px;
        border: 1px solid rgba(255, 255, 255, 0.16);
        border-radius: 7px;
        background: var(--bg-input);
        color: #eef4ff;
        padding: 4px 6px;
        box-sizing: border-box;
        font-family: Consolas, "Courier New", monospace;
        font-size: 12px;
      }

      .col-x {
        border-color: rgba(253, 138, 138, 0.9) !important;
        background: rgba(201, 77, 77, 0.22) !important;
      }

      .col-y {
        border-color: rgba(117, 214, 150, 0.92) !important;
        background: rgba(51, 150, 80, 0.24) !important;
      }

      .col-z {
        border-color: rgba(125, 176, 255, 0.95) !important;
        background: rgba(49, 96, 178, 0.24) !important;
      }

      .col-t {
        border-color: rgba(241, 194, 109, 0.95) !important;
        background: rgba(168, 123, 49, 0.25) !important;
      }

      .label-x {
        background: #ef4444;
      }

      .label-y {
        background: #22c55e;
      }

      .label-z {
        background: #3b82f6;
      }

      .label-t {
        background: #f59e0b;
      }

      .matrix-actions {
        margin-top: 8px;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .matrix-actions input,
      .matrix-actions select {
        height: 30px;
        border: 1px solid rgba(255, 255, 255, 0.16);
        border-radius: 7px;
        background: var(--bg-input);
        color: #ebf0fb;
        padding: 4px 6px;
      }

      .matrix-status {
        margin-top: 8px;
        min-height: 16px;
        color: #c4cfdf;
      }

      .operation-output {
        margin-top: 8px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 7px;
        background: rgba(0, 0, 0, 0.14);
      }

      .operation-output h3 {
        margin: 0;
        padding: 6px 8px;
        font-size: 12px;
        font-weight: 600;
      }

      .operation-output pre {
        margin: 0;
        padding: 0 8px 8px;
        white-space: pre-wrap;
        font-size: 11px;
        color: #d6deeb;
        font-family: Consolas, "Courier New", monospace;
      }

      .applied-list {
        margin: 0;
      }

      .applied-list h3 {
        margin: 0 0 8px;
        font-size: 13px;
        font-weight: 600;
      }

      .chain-output {
        margin-bottom: 8px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 7px;
        background: rgba(0, 0, 0, 0.14);
      }

      .chain-output pre {
        margin: 0;
        padding: 8px;
        white-space: pre-wrap;
        font-size: 11px;
        color: #d6deeb;
        font-family: Consolas, "Courier New", monospace;
      }

      .applied-empty {
        color: #9aa8be;
      }

      .applied-item {
        margin-bottom: 6px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 7px;
        background: rgba(0, 0, 0, 0.12);
      }

      .applied-item summary {
        cursor: pointer;
        padding: 6px 8px;
        font-weight: 600;
      }

      .applied-item pre {
        margin: 0;
        padding: 0 8px 8px;
        white-space: pre-wrap;
        font-size: 11px;
        color: #d8e2f2;
        font-family: Consolas, "Courier New", monospace;
      }

      .applied-item button {
        margin: 0 8px 8px;
        border-radius: 7px;
        padding: 5px 9px;
        font-size: 11px;
      }

      .viz-label {
        position: fixed;
        pointer-events: none;
        transform: translate(-50%, -120%);
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 11px;
        font-family: Consolas, "Courier New", monospace;
        color: #0b1020;
        font-weight: 700;
        z-index: 20;
        white-space: nowrap;
      }

      .viz-label-origin {
        background: #ffffff;
      }

      .viz-label-x {
        background: #ff6b6b;
      }

      .viz-label-y {
        background: #66d184;
      }

      .viz-label-point {
        background: #7dd3fc;
      }

      .world-axis-label {
        position: fixed;
        pointer-events: none;
        transform: translate(-50%, -120%);
        padding: 2px 7px;
        border-radius: 999px;
        font-size: 11px;
        font-family: Consolas, "Courier New", monospace;
        color: #0b1020;
        font-weight: 700;
        z-index: 20;
        white-space: nowrap;
        border: 1px solid rgba(0, 0, 0, 0.35);
      }

      .world-axis-x {
        background: #ff7777;
      }

      .world-axis-y {
        background: #7be39a;
      }

      .world-axis-z {
        background: #7fb3ff;
      }

      .state-badge-row {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        margin-bottom: 8px;
      }

      .state-badge {
        border: 1px solid rgba(255, 255, 255, 0.18);
        background: rgba(255, 255, 255, 0.06);
        color: #d9e4f6;
        border-radius: 999px;
        padding: 3px 8px;
        font-size: 11px;
        font-weight: 600;
      }

      .state-equation {
        margin: 0 0 8px;
        color: #c4d2ea;
        font-size: 12px;
      }

      .state-translation {
        margin: 0;
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        padding: 8px;
        background: rgba(255, 255, 255, 0.03);
        color: #edf3ff;
        font-family: Consolas, "Courier New", monospace;
        font-size: 12px;
      }

      .state-matrix {
        width: 100%;
        border-collapse: collapse;
        font-family: Consolas, "Courier New", monospace;
        font-size: 12px;
      }

      .state-matrix th,
      .state-matrix td {
        border: 1px solid rgba(255, 255, 255, 0.1);
        padding: 4px 6px;
        text-align: center;
      }

      .state-matrix th {
        color: #bcd0f3;
        font-weight: 600;
        background: rgba(255, 255, 255, 0.04);
      }

      .state-matrix td {
        color: #f3f7ff;
        background: rgba(255, 255, 255, 0.02);
      }

      .math-card {
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 9px;
        background: rgba(255, 255, 255, 0.03);
        padding: 8px;
        margin-bottom: 8px;
      }

      .math-label {
        font-size: 11px;
        font-weight: 700;
        color: #b9cae7;
        margin: 0 0 6px;
      }

      .math-equation {
        margin: 0 0 6px;
        color: #eef4ff;
        font-family: Consolas, "Courier New", monospace;
        font-size: 12px;
      }

      .math-steps {
        margin: 0;
        color: #d8e3f7;
        font-family: Consolas, "Courier New", monospace;
        font-size: 11px;
        line-height: 1.4;
      }

      .math-anim-grid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 8px;
        margin-top: 8px;
      }

      .math-anim-head {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
      }

      .math-anim-label {
        margin: 0;
        font-size: 11px;
        font-weight: 700;
        color: #b9cae7;
      }

      .math-anim-eq {
        margin: 6px 0 0;
        font-family: Consolas, "Courier New", monospace;
        font-size: 12px;
        color: #eef4ff;
      }

      .math-anim-mats {
        display: grid;
        gap: 8px;
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }

      .math-anim-mat {
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        padding: 6px;
        background: rgba(255, 255, 255, 0.02);
      }

      .math-anim-mat-title {
        margin: 0 0 6px;
        font-size: 11px;
        font-weight: 700;
        color: #b9cae7;
      }

      .math-active-row {
        background: rgba(251, 191, 36, 0.16) !important;
      }

      .math-active-col {
        box-shadow: inset 0 0 0 1px rgba(251, 191, 36, 0.55);
      }

      .math-active-cell {
        background: rgba(59, 130, 246, 0.24) !important;
        box-shadow: inset 0 0 0 1px rgba(125, 180, 255, 0.7);
      }

      .math-dot-terms {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        margin-top: 6px;
      }

      .math-dot-term {
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 999px;
        padding: 2px 8px;
        font-family: Consolas, "Courier New", monospace;
        font-size: 11px;
        color: #d8e3f7;
        background: rgba(255, 255, 255, 0.03);
      }

      .math-dot-term-active {
        background: rgba(125, 180, 255, 0.22);
        border-color: rgba(125, 180, 255, 0.65);
        color: #eff6ff;
      }

      .math-dot-term-done {
        background: rgba(123, 227, 163, 0.16);
        border-color: rgba(123, 227, 163, 0.55);
      }

      .math-anim-scrub {
        margin-top: 8px;
        display: grid;
        gap: 4px;
      }

      .math-anim-scrub input[type="range"] {
        width: 100%;
      }

      @media (max-width: 1040px) {
        .math-anim-mats {
          grid-template-columns: 1fr;
        }
      }

      .math-axis-x {
        color: #ff8d8d !important;
      }

      .math-axis-y {
        color: #85e3a3 !important;
      }

      .math-axis-z {
        color: #8ebcff !important;
      }

      .math-axis-t {
        color: #ffd28b !important;
      }

      .math-axis-d {
        color: #ffd28b !important;
      }

      .point-controls {
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 8px;
      }

      .axis-control {
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 8px;
        padding: 6px;
        background: rgba(255, 255, 255, 0.03);
      }

      .axis-control label {
        display: block;
        margin-bottom: 4px;
        font-size: 11px;
        font-weight: 700;
      }

      .axis-control input {
        width: 100%;
        height: 28px;
        border: 1px solid rgba(255, 255, 255, 0.18);
        border-radius: 6px;
        background: #111722;
        color: #eef4ff;
        padding: 4px 6px;
        box-sizing: border-box;
        font-family: Consolas, "Courier New", monospace;
        font-size: 12px;
      }

      .axis-control-x {
        border-left: 3px solid #ef7373;
      }

      .axis-control-x label {
        color: #ffb8b8;
      }

      .axis-control-y {
        border-left: 3px solid #7cdd99;
      }

      .axis-control-y label {
        color: #baf5cb;
      }

      .axis-control-z {
        border-left: 3px solid #7fb3ff;
      }

      .axis-control-z label {
        color: #c2dbff;
      }

      .point-controls-actions {
        margin-top: 8px;
      }

      @media (max-width: 920px) {
        .hud {
          top: 8px;
          left: 8px;
          font-size: 12px;
          max-width: calc(100vw - 16px);
        }

        .controls {
          top: auto;
          bottom: 8px;
          right: 8px;
          max-width: calc(100vw - 16px);
          padding: 8px;
        }

        .matrix-panel {
          left: 8px;
          right: 8px;
          bottom: 96px;
          width: auto;
          max-height: calc(100vh - 210px);
        }

        .math-panel {
          left: 8px;
          right: 8px;
          bottom: 8px;
          width: auto;
          max-height: 32vh;
        }

        .current-state-panel {
          left: 8px;
          right: 8px;
          top: auto;
          bottom: calc(8px + 32vh + 8px);
          width: auto;
          max-height: 22vh;
        }
      }
    </style>
  </head>
  <body>
    <div id="app"></div>
    <div class="hud">
      Matrix Multiplication Demo Visualization<br />
      Made by Carlos Matecki<br />
      X axis: Red | Y axis: Green | Z axis: Blue<br />
      Orange path: cumulative translation from origin
    </div>
      <div class="controls">
      <div class="control-row">
        <span id="modeLabel">Mode: 2D</span>
        <button id="modeToggle" type="button">Switch to 3D</button>
        <span id="toolModeLabel">Tool: Transform</span>
        <button id="toolModeToggle" type="button">Matrix Viz</button>
      </div>
      <div class="panel-toggle-row" aria-label="Panel visibility">
        <button class="panel-toggle" type="button" data-panel-target="panelMatrixEditor" data-active="true">Matrix</button>
        <button class="panel-toggle" type="button" data-panel-target="panelMultiply" data-active="true">Multiply</button>
        <button class="panel-toggle" type="button" data-panel-target="panelConfig" data-active="true">Config</button>
        <button class="panel-toggle" type="button" data-panel-target="panelCurrentContainer" data-active="false">Current</button>
        <button class="panel-toggle" type="button" data-panel-target="panelMathContainer" data-active="false">Math</button>
        <button class="panel-toggle" type="button" data-panel-target="appliedSection" data-active="false">Chain</button>
      </div>
    </div>
    <div id="vizLabelOrigin" class="viz-label viz-label-origin hidden">O (0, 0)</div>
    <div id="vizLabelX" class="viz-label viz-label-x hidden">X (1, 0)</div>
    <div id="vizLabelY" class="viz-label viz-label-y hidden">Y (0, 1)</div>
    <div id="pointWorldLabel" class="viz-label viz-label-point hidden">P (0, 0, 0)</div>
    <div id="worldAxisLabelX" class="world-axis-label world-axis-x hidden">X axis</div>
    <div id="worldAxisLabelY" class="world-axis-label world-axis-y hidden">Y axis</div>
    <div id="worldAxisLabelZ" class="world-axis-label world-axis-z hidden">Z axis</div>
    <div class="matrix-panel">
      <div id="panelMatrixEditor" class="panel-section">
        <div class="panel-header">
          <h3 id="matrixTitle">Cube Matrix (4x4)</h3>
          <p class="panel-subtitle">Editor</p>
        </div>
        <div id="matrixColumnLabels" class="matrix-col-labels"></div>
        <div id="matrixGrid" class="matrix-grid"></div>
        <div id="vizHint" class="matrix-status hidden">
          Matrix Visualization mode: edit the matrix to preview transformed X/Y axes only.
        </div>
        <div id="vizAxisReadout" class="operation-output hidden">
          <h3>Viz Axis Values</h3>
          <div class="matrix-actions">
            <button id="vizTrigToggle" type="button">Trig View: Off</button>
          </div>
          <pre id="vizAxisText">origin = (0, 0)
x_axis = (1, 0)
y_axis = (0, 1)</pre>
        </div>
        <div class="matrix-status">Trig inputs use degrees: `cos 90`, `sin(45)`, `tan 30`.</div>
      </div>

      <div id="panelConfig" class="panel-section">
        <h3>Configuration</h3>
        <div class="matrix-actions">
          <select id="transformObjectMode">
            <option value="cube">Object: Cube</option>
            <option value="point" selected>Object: Point</option>
          </select>
          <button id="copyCurrent" type="button">Copy Current</button>
          <button id="identityTarget" type="button">Identity</button>
          <button id="resetCube" type="button">Reset Cube</button>
        </div>
        <div class="matrix-actions">
          <select id="chainStepSelect">
            <option value="">Edit Step: None</option>
          </select>
          <button id="revertSelectedStep" type="button">Revert Selected</button>
          <button id="chainModeTranslate" type="button">Translate</button>
          <button id="chainModeRotate" type="button">Rotate</button>
          <button id="chainModeScale" type="button">Scale</button>
        </div>
      </div>

      <div id="panelMultiply" class="panel-section">
        <h3>Multiplication</h3>
        <div class="matrix-actions">
          <button id="applyMatrix" type="button">Apply Multiply</button>
          <button id="directMultiply" type="button">Direct Multiply</button>
          <button id="revertByInverse" type="button">Revert (Inverse)</button>
          <button id="setMatrix" type="button">Apply Set</button>
          <button id="replayTransformations" type="button">Replay Transformations</button>
          <button id="doTransformation" type="button">Do Transformation</button>
        </div>
        <div id="matrixStatus" class="matrix-status"></div>
      </div>

      <div id="appliedSection" class="applied-list panel-section hidden">
        <h3>Applied Matrices</h3>
        <div id="appliedMatrixList" class="applied-empty">No matrices applied yet.</div>
      </div>
    </div>
    <div id="panelMathContainer" class="math-panel hidden">
      <div id="panelMath" class="panel-section">
        <h3>Math Visualizer</h3>
        <div id="mathFormOutput"></div>
      </div>
    </div>
    <div id="panelCurrentContainer" class="current-state-panel hidden">
      <div id="panelCurrent" class="panel-section">
        <h3>Current Object State</h3>
        <div id="currentStateContent"></div>
      </div>
    </div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { TransformControls } from "three/addons/controls/TransformControls.js";
      import { renderCurrentStatePanel } from "./object-state-panel.js";

      const container = document.getElementById("app");

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x10151d);

      const camera3D = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera3D.position.set(12, 10, 12);

      const frustumSize = 28;
      const aspect = window.innerWidth / window.innerHeight;
      const camera2D = new THREE.OrthographicCamera(
        (-frustumSize * aspect) / 2,
        (frustumSize * aspect) / 2,
        frustumSize / 2,
        -frustumSize / 2,
        0.1,
        1000
      );
      camera2D.position.set(0, 0, 24);
      camera2D.lookAt(0, 0, 0);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      container.appendChild(renderer.domElement);

      let activeCamera = camera2D;
      let controls;
      let is2D = true;

      function createControls(camera, mode2D) {
        if (controls) controls.dispose();
        controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 0, 0);
        controls.enableDamping = true;
        controls.enableRotate = !mode2D;
        controls.enablePan = true;
        controls.screenSpacePanning = true;
        if (mode2D) {
          controls.minPolarAngle = Math.PI / 2;
          controls.maxPolarAngle = Math.PI / 2;
        } else {
          controls.minPolarAngle = 0;
          controls.maxPolarAngle = Math.PI;
        }
        controls.update();
        createOrRefreshChainControl(camera);
      }

      function createOrRefreshChainControl(camera) {
        if (chainControl) {
          scene.remove(chainControl);
          chainControl.dispose();
          chainControl = null;
        }
        chainControl = new TransformControls(camera, renderer.domElement);
        chainControl.setMode(chainControlMode === "none" ? "translate" : chainControlMode);
        chainControl.setSize(0.7);
        chainControl.addEventListener("dragging-changed", (event) => {
          controls.enabled = !event.value;
        });
        chainControl.addEventListener("objectChange", () => {
          if (toolMode !== "transform" || selectedAppliedStepIndex < 0) return;
          const steps = getAppliedChainData();
          const step = steps[selectedAppliedStepIndex];
          if (!step) return;

          chainControlProxy.updateMatrix();
          const cumulativeNew = chainControlProxy.matrix.clone();
          const prefixInv = step.prefix.clone();
          if (Math.abs(prefixInv.determinant()) < 1e-8) return;
          prefixInv.invert();
          const localNew = prefixInv.multiply(cumulativeNew);
          appliedMatrices[selectedAppliedStepIndex].rowMajor = getRowMajorFromMatrix(localNew);
          recomputeFinalFromAppliedChain();
          renderAppliedMatrices();
        });
        scene.add(chainControl);
        syncChainControlAttachment();
      }

      function syncChainControlModeButtons() {
        const activeBg = "rgba(220, 233, 255, 0.22)";
        const inactiveBg = "rgba(255, 255, 255, 0.06)";
        const activeColor = "#f3f5f8";
        const inactiveColor = "#f3f5f8";
        chainModeTranslate.style.background = chainControlMode === "translate" ? activeBg : inactiveBg;
        chainModeRotate.style.background = chainControlMode === "rotate" ? activeBg : inactiveBg;
        chainModeScale.style.background = chainControlMode === "scale" ? activeBg : inactiveBg;
        chainModeTranslate.style.color = chainControlMode === "translate" ? activeColor : inactiveColor;
        chainModeRotate.style.color = chainControlMode === "rotate" ? activeColor : inactiveColor;
        chainModeScale.style.color = chainControlMode === "scale" ? activeColor : inactiveColor;
      }

      function syncChainControlAttachment() {
        if (!chainControl) return;
        if (chainControlMode === "none") {
          chainControl.detach();
          chainControl.visible = false;
          return;
        }
        chainControl.setMode(chainControlMode);
        if (toolMode !== "transform" || selectedAppliedStepIndex < 0 || selectedAppliedStepIndex >= appliedMatrices.length) {
          chainControl.detach();
          chainControl.visible = false;
          return;
        }
        const steps = getAppliedChainData();
        const step = steps[selectedAppliedStepIndex];
        if (!step) {
          chainControl.detach();
          chainControl.visible = false;
          return;
        }
        const pos = new THREE.Vector3();
        const quat = new THREE.Quaternion();
        const scl = new THREE.Vector3();
        step.cumulative.decompose(pos, quat, scl);
        chainControlProxy.position.copy(pos);
        chainControlProxy.quaternion.copy(quat);
        chainControlProxy.scale.copy(scl);
        chainControlProxy.updateMatrix();
        chainControl.attach(chainControlProxy);
        chainControl.visible = true;
      }

      scene.add(new THREE.AxesHelper(8));

      const size = 24;
      const divisions = 24;
      function styleGrid(grid, opacity) {
        const mats = Array.isArray(grid.material) ? grid.material : [grid.material];
        for (const mat of mats) {
          mat.transparent = true;
          mat.opacity = opacity;
        }
      }

      const gridXZ = new THREE.GridHelper(size, divisions, 0xffffff, 0x7f8ea3);
      gridXZ.position.set(0, 0, 0);
      styleGrid(gridXZ, 0.3);
      scene.add(gridXZ);

      const gridXY = new THREE.GridHelper(size, divisions, 0xffffff, 0x7f8ea3);
      gridXY.rotation.x = Math.PI / 2;
      gridXY.position.set(0, 0, 0);
      styleGrid(gridXY, 0.2);
      scene.add(gridXY);

      const gridYZ = new THREE.GridHelper(size, divisions, 0xffffff, 0x7f8ea3);
      gridYZ.rotation.z = Math.PI / 2;
      gridYZ.position.set(0, 0, 0);
      styleGrid(gridYZ, 0.2);
      scene.add(gridYZ);

      const ambient = new THREE.AmbientLight(0xffffff, 0.9);
      scene.add(ambient);
      const key = new THREE.DirectionalLight(0xffffff, 0.45);
      key.position.set(6, 8, 5);
      scene.add(key);

      const cubeGeometry = new THREE.BoxGeometry(2, 2, 2);
      const cubeMaterial = new THREE.MeshStandardMaterial({
        color: 0xffb74d,
        roughness: 0.45,
        metalness: 0.08,
        transparent: true,
        opacity: 0.3,
        depthWrite: false
      });
      const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
      cube.matrixAutoUpdate = false;
      cube.matrix.identity();
      scene.add(cube);

      const point = new THREE.Mesh(
        new THREE.SphereGeometry(0.18, 18, 18),
        new THREE.MeshStandardMaterial({ color: 0x7dd3fc, emissive: 0x0f172a })
      );
      point.matrixAutoUpdate = false;
      point.matrix.identity();
      point.visible = false;
      scene.add(point);

      const translationVizGroup = new THREE.Group();
      scene.add(translationVizGroup);
      const matrixVizGroup = new THREE.Group();
      scene.add(matrixVizGroup);
      const pointWorldVizGroup = new THREE.Group();
      scene.add(pointWorldVizGroup);

      const pointWorldPath = new THREE.Line(
        new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]),
        new THREE.LineDashedMaterial({
          color: 0x7dd3fc,
          dashSize: 0.3,
          gapSize: 0.2,
          transparent: true,
          opacity: 0.42
        })
      );
      pointWorldVizGroup.add(pointWorldPath);

      const pointWorldProjection = new THREE.Line(
        new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]),
        new THREE.LineDashedMaterial({
          color: 0x7dd3fc,
          dashSize: 0.24,
          gapSize: 0.2,
          transparent: true,
          opacity: 0.38
        })
      );
      pointWorldVizGroup.add(pointWorldProjection);

      const pointWorldProjectedDot = new THREE.Mesh(
        new THREE.SphereGeometry(0.08, 10, 10),
        new THREE.MeshBasicMaterial({ color: 0x7dd3fc, transparent: true, opacity: 0.8 })
      );
      pointWorldVizGroup.add(pointWorldProjectedDot);
      pointWorldVizGroup.visible = false;

      const modeLabel = document.getElementById("modeLabel");
      const modeToggle = document.getElementById("modeToggle");
      const toolModeLabel = document.getElementById("toolModeLabel");
      const toolModeToggle = document.getElementById("toolModeToggle");
      const matrixTitle = document.getElementById("matrixTitle");
      const matrixColumnLabels = document.getElementById("matrixColumnLabels");
      const matrixGrid = document.getElementById("matrixGrid");
      const transformObjectMode = document.getElementById("transformObjectMode");
      const copyCurrent = document.getElementById("copyCurrent");
      const identityTarget = document.getElementById("identityTarget");
      const applyMatrix = document.getElementById("applyMatrix");
      const directMultiply = document.getElementById("directMultiply");
      const revertByInverse = document.getElementById("revertByInverse");
      const setMatrix = document.getElementById("setMatrix");
      const resetCube = document.getElementById("resetCube");
      const replayTransformations = document.getElementById("replayTransformations");
      const doTransformation = document.getElementById("doTransformation");
      const matrixStatus = document.getElementById("matrixStatus");
      const operationOutput = document.getElementById("operationOutput");
      const mathFormOutput = document.getElementById("mathFormOutput");
      const currentStateContent = document.getElementById("currentStateContent");
      const vizHint = document.getElementById("vizHint");
      const vizAxisReadout = document.getElementById("vizAxisReadout");
      const vizTrigToggle = document.getElementById("vizTrigToggle");
      const vizAxisText = document.getElementById("vizAxisText");
      const vizLabelOrigin = document.getElementById("vizLabelOrigin");
      const vizLabelX = document.getElementById("vizLabelX");
      const vizLabelY = document.getElementById("vizLabelY");
      const pointWorldLabel = document.getElementById("pointWorldLabel");
      const worldAxisLabelX = document.getElementById("worldAxisLabelX");
      const worldAxisLabelY = document.getElementById("worldAxisLabelY");
      const worldAxisLabelZ = document.getElementById("worldAxisLabelZ");
      const appliedSection = document.getElementById("appliedSection");
      const chainStepSelect = document.getElementById("chainStepSelect");
      const revertSelectedStep = document.getElementById("revertSelectedStep");
      const chainModeTranslate = document.getElementById("chainModeTranslate");
      const chainModeRotate = document.getElementById("chainModeRotate");
      const chainModeScale = document.getElementById("chainModeScale");
      const appliedMatrixList = document.getElementById("appliedMatrixList");
      const panelToggleButtons = Array.from(document.querySelectorAll(".panel-toggle"));
      const transformControls = [
        transformObjectMode,
        copyCurrent,
        identityTarget,
        applyMatrix,
        directMultiply,
        revertByInverse,
        setMatrix,
        resetCube,
        replayTransformations,
        doTransformation,
        revertSelectedStep
      ];

      let matrixInputs = [];
      let editorMode = "3d";
      let toolMode = "transform";
      let transformEntityMode = "point";
      let transformEditorMatrix = null;
      let vizEditorMatrix = null;
      let transformViewIs2D = true;
      let matrixVizHandles = { origin: null, x: null, y: null };
      let vizTrigMode = false;
      let chainControl = null;
      const chainControlProxy = new THREE.Object3D();
      scene.add(chainControlProxy);
      let selectedAppliedStepIndex = -1;
      let chainControlMode = "none";
      let chainBaseMatrix = new THREE.Matrix4().identity();
      let currentGlobalMatrix = new THREE.Matrix4().identity();
      let pointBaseMatrix = new THREE.Matrix4().identity();
      const raycaster = new THREE.Raycaster();
      const pointerNdc = new THREE.Vector2();
      const dragPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
      let dragState = null;
      let interpolation = null;
      let mathMulAnimation = null;
      let mathMulManualStep = 0;
      let mathMulManualSize = 4;
      let mathMulLastRenderedStep = -1;
      const INTERP_DURATION_MS = 1200;

      function setPanelVisible(panelId, show) {
        const panel = document.getElementById(panelId);
        if (!panel) return;
        panel.classList.toggle("hidden", !show);
        panelToggleButtons.forEach((button) => {
          if (button.getAttribute("data-panel-target") !== panelId) return;
          button.setAttribute("data-active", show ? "true" : "false");
          button.setAttribute("aria-pressed", show ? "true" : "false");
        });
      }

      function initPanelToggles() {
        panelToggleButtons.forEach((button) => {
          const panelId = button.getAttribute("data-panel-target");
          if (!panelId) return;
          const panel = document.getElementById(panelId);
          if (!panel) return;
          button.setAttribute("aria-pressed", panel.classList.contains("hidden") ? "false" : "true");
          button.setAttribute("data-active", panel.classList.contains("hidden") ? "false" : "true");
          button.addEventListener("click", () => {
            const isVisible = !panel.classList.contains("hidden");
            setPanelVisible(panelId, !isVisible);
          });
        });
      }

      function createIdentityMatrix() {
        const m = new THREE.Matrix4();
        m.identity();
        return m;
      }

      function rebuildMatrixEditor(nextMode, sourceMatrix) {
        editorMode = nextMode;
        matrixTitle.textContent = `Cube Matrix (${editorMode === "2d" ? "3x3" : "4x4"})`;
        const cols = editorMode === "2d" ? 3 : 4;
        const colDefs = editorMode === "2d"
          ? [
              { label: "X", cls: "x" },
              { label: "Y", cls: "y" },
              { label: "T", cls: "t" }
            ]
          : [
              { label: "X", cls: "x" },
              { label: "Y", cls: "y" },
              { label: "Z", cls: "z" },
              { label: "T", cls: "t" }
            ];

        matrixGrid.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
        matrixColumnLabels.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
        matrixColumnLabels.innerHTML = colDefs
          .map((col) => `<div class="matrix-col-label label-${col.cls}">${col.label}</div>`)
          .join("");
        matrixGrid.innerHTML = "";
        matrixInputs = [];
        const total = editorMode === "2d" ? 9 : 16;
        for (let i = 0; i < total; i += 1) {
          const input = document.createElement("input");
          input.type = "text";
          input.spellcheck = false;
          input.value = "0";
          const colClass = `col-${colDefs[i % cols].cls}`;
          input.classList.add(colClass);
          input.addEventListener("input", onMatrixEditorInputChanged);
          matrixGrid.appendChild(input);
          matrixInputs.push(input);
        }
        setInputsFromMatrix(sourceMatrix || createIdentityMatrix());
      }

      function tryReadMatrixFromInputs() {
        try {
          return readMatrixFromInputs();
        } catch {
          return null;
        }
      }

      function getRowMajorFromMatrix(m) {
        const e = m.elements;
        return [
          e[0], e[4], e[8], e[12],
          e[1], e[5], e[9], e[13],
          e[2], e[6], e[10], e[14],
          e[3], e[7], e[11], e[15]
        ];
      }

      function setInputsFromMatrix(m) {
        const rowMajor4 = getRowMajorFromMatrix(m);
        if (editorMode === "2d") {
          if (toolMode === "viz" && vizTrigMode) {
            const { a, b, tx, c, d, ty } = get2DComponentsFromMatrix(m);
            const sx = Math.hypot(a, c);
            const sy = Math.hypot(b, d);
            const thetaDeg = (Math.atan2(c, a) * 180) / Math.PI;
            const thetaText = formatValue(thetaDeg);
            const sxText = formatValue(sx);
            const syText = formatValue(sy);

            matrixInputs[0].value = `${sxText}*cos(${thetaText})`;
            matrixInputs[1].value = `-${syText}*sin(${thetaText})`;
            matrixInputs[2].value = String(formatValue(tx));
            matrixInputs[3].value = `${sxText}*sin(${thetaText})`;
            matrixInputs[4].value = `${syText}*cos(${thetaText})`;
            matrixInputs[5].value = String(formatValue(ty));
            matrixInputs[6].value = "0";
            matrixInputs[7].value = "0";
            matrixInputs[8].value = "1";
            updateMathVisualizer();
            return;
          }

          const rowMajor3 = [
            rowMajor4[0], rowMajor4[1], rowMajor4[3],
            rowMajor4[4], rowMajor4[5], rowMajor4[7],
            rowMajor4[12], rowMajor4[13], rowMajor4[15]
          ];
          for (let i = 0; i < 9; i += 1) {
            matrixInputs[i].value = String(rowMajor3[i]);
          }
          updateMathVisualizer();
          return;
        }
        for (let i = 0; i < 16; i += 1) {
          matrixInputs[i].value = String(rowMajor4[i]);
        }
        updateMathVisualizer();
      }

      function getActiveTransformObject() {
        return transformEntityMode === "point" ? point : cube;
      }

      function getActiveTransformLabel() {
        return transformEntityMode === "point" ? "point" : "cube";
      }

      function getActiveTransformMatrix() {
        return getActiveTransformObject().matrix.clone();
      }

      function getGlobalTransformMatrix() {
        return currentGlobalMatrix.clone();
      }

      function setActiveTransformMatrix(nextMatrix) {
        currentGlobalMatrix = nextMatrix.clone();
        cube.matrix.copy(currentGlobalMatrix);
        cube.matrixWorldNeedsUpdate = true;
        const pointFinal = pointBaseMatrix.clone().multiply(currentGlobalMatrix);
        point.matrix.copy(pointFinal);
        point.matrixWorldNeedsUpdate = true;
        updateCurrentStatePanel();
        updateMathVisualizer();
      }

      function syncTransformEntityVisibility() {
        if (toolMode === "viz") {
          cube.visible = false;
          point.visible = false;
          return;
        }
        cube.visible = transformEntityMode === "cube";
        point.visible = transformEntityMode === "point";
      }

      function formatValue(value) {
        return Number(value.toFixed(4)).toString();
      }

      function toRowMajorText(rowMajor) {
        const lines = [];
        for (let row = 0; row < 4; row += 1) {
          const base = row * 4;
          lines.push(
            `${formatValue(rowMajor[base])} ${formatValue(rowMajor[base + 1])} ${formatValue(rowMajor[base + 2])} ${formatValue(rowMajor[base + 3])}`
          );
        }
        return lines.join("\n");
      }

      function matrixToText(matrix4) {
        return toRowMajorText(getRowMajorFromMatrix(matrix4));
      }

      function updateCurrentStatePanel() {
        if (!currentStateContent) return;
        const entityLabel = getActiveTransformLabel();
        const currentMatrix = entityLabel === "point" ? pointBaseMatrix.clone() : getActiveTransformMatrix();
        const translation = new THREE.Vector3().setFromMatrixPosition(currentMatrix);
        currentStateContent.innerHTML = renderCurrentStatePanel({
          entityLabel,
          translation: { x: translation.x, y: translation.y, z: translation.z },
          rowMajor: getRowMajorFromMatrix(currentMatrix),
          formatValue
        });

        if (entityLabel === "point") {
          const txInput = currentStateContent.querySelector('[data-point-translate="x"]');
          const tyInput = currentStateContent.querySelector('[data-point-translate="y"]');
          const tzInput = currentStateContent.querySelector('[data-point-translate="z"]');
          const applyBtn = currentStateContent.querySelector('[data-action="apply-point-translation"]');
          if (!txInput || !tyInput || !tzInput || !applyBtn) return;

          const applyPointTranslation = () => {
            const tx = Number(txInput.value);
            const ty = Number(tyInput.value);
            const tz = Number(tzInput.value);
            if (!Number.isFinite(tx) || !Number.isFinite(ty) || !Number.isFinite(tz)) {
              matrixStatus.textContent = "Point translation must be numeric.";
              return;
            }
            const next = pointBaseMatrix.clone();
            next.setPosition(tx, ty, tz);
            pointBaseMatrix = next;
            setActiveTransformMatrix(getGlobalTransformMatrix());
            setInputsFromMatrix(getGlobalTransformMatrix());
            transformEditorMatrix = getGlobalTransformMatrix();
            matrixStatus.textContent = "Point translation updated.";
          };

          applyBtn.addEventListener("click", applyPointTranslation);
          [txInput, tyInput, tzInput].forEach((input) => {
            input.addEventListener("keydown", (event) => {
              if (event.key === "Enter") applyPointTranslation();
            });
          });
        }
      }

      function matrixToEquationText(matrix4) {
        const rowMajor = getRowMajorFromMatrix(matrix4);
        const lines = [];
        for (let row = 0; row < 4; row += 1) {
          const base = row * 4;
          lines.push(
            `| ${formatValue(rowMajor[base])} ${formatValue(rowMajor[base + 1])} ${formatValue(rowMajor[base + 2])} ${formatValue(rowMajor[base + 3])} |`
          );
        }
        return lines.join("\n");
      }

      function toRowMajor3FromMatrix4(matrixOrRowMajor) {
        const rowMajor4 = Array.isArray(matrixOrRowMajor)
          ? matrixOrRowMajor
          : getRowMajorFromMatrix(matrixOrRowMajor);
        return [
          rowMajor4[0], rowMajor4[1], rowMajor4[3],
          rowMajor4[4], rowMajor4[5], rowMajor4[7],
          rowMajor4[12], rowMajor4[13], rowMajor4[15]
        ];
      }

      function multiplyRowMajor(leftRowMajor, rightRowMajor, size) {
        const out = new Array(size * size).fill(0);
        for (let r = 0; r < size; r += 1) {
          for (let c = 0; c < size; c += 1) {
            let sum = 0;
            for (let k = 0; k < size; k += 1) {
              sum += leftRowMajor[r * size + k] * rightRowMajor[k * size + c];
            }
            out[r * size + c] = sum;
          }
        }
        return out;
      }

      function matrixToHtmlTable(matrixOrRowMajor, options = {}) {
        const size = options.size === 3 ? 3 : 4;
        const rowMajor = Array.isArray(matrixOrRowMajor)
          ? matrixOrRowMajor
          : size === 3
            ? toRowMajor3FromMatrix4(matrixOrRowMajor)
            : getRowMajorFromMatrix(matrixOrRowMajor);
        const activeRow = Number.isInteger(options.activeRow) ? options.activeRow : -1;
        const activeCol = Number.isInteger(options.activeCol) ? options.activeCol : -1;
        const activeCellRow = Number.isInteger(options.activeCellRow) ? options.activeCellRow : -1;
        const activeCellCol = Number.isInteger(options.activeCellCol) ? options.activeCellCol : -1;
        const rows = [];
        for (let row = 0; row < size; row += 1) {
          const base = row * size;
          const rowClass = row === activeRow ? " math-active-row" : "";
          if (size === 3) {
            rows.push(
              `<tr>
                <th class="${rowClass.trim()}">r${row + 1}</th>
                <td class="math-axis-x${rowClass}${activeCol === 0 ? " math-active-col" : ""}${activeCellRow === row && activeCellCol === 0 ? " math-active-cell" : ""}">${formatValue(rowMajor[base])}</td>
                <td class="math-axis-y${rowClass}${activeCol === 1 ? " math-active-col" : ""}${activeCellRow === row && activeCellCol === 1 ? " math-active-cell" : ""}">${formatValue(rowMajor[base + 1])}</td>
                <td class="math-axis-d${rowClass}${activeCol === 2 ? " math-active-col" : ""}${activeCellRow === row && activeCellCol === 2 ? " math-active-cell" : ""}">${formatValue(rowMajor[base + 2])}</td>
              </tr>`
            );
          } else {
            rows.push(
              `<tr>
                <th class="${rowClass.trim()}">r${row + 1}</th>
                <td class="math-axis-x${rowClass}${activeCol === 0 ? " math-active-col" : ""}${activeCellRow === row && activeCellCol === 0 ? " math-active-cell" : ""}">${formatValue(rowMajor[base])}</td>
                <td class="math-axis-y${rowClass}${activeCol === 1 ? " math-active-col" : ""}${activeCellRow === row && activeCellCol === 1 ? " math-active-cell" : ""}">${formatValue(rowMajor[base + 1])}</td>
                <td class="math-axis-z${rowClass}${activeCol === 2 ? " math-active-col" : ""}${activeCellRow === row && activeCellCol === 2 ? " math-active-cell" : ""}">${formatValue(rowMajor[base + 2])}</td>
                <td class="math-axis-t${rowClass}${activeCol === 3 ? " math-active-col" : ""}${activeCellRow === row && activeCellCol === 3 ? " math-active-cell" : ""}">${formatValue(rowMajor[base + 3])}</td>
              </tr>`
            );
          }
        }
        return `
          <table class="state-matrix">
            <thead>
              ${size === 3
                ? '<tr><th></th><th class="math-axis-x">X</th><th class="math-axis-y">Y</th><th class="math-axis-d">D</th></tr>'
                : '<tr><th></th><th class="math-axis-x">X</th><th class="math-axis-y">Y</th><th class="math-axis-z">Z</th><th class="math-axis-t">T</th></tr>'
              }
            </thead>
            <tbody>${rows.join("")}</tbody>
          </table>
        `;
      }

      function getMathMulTotalSteps(size) {
        return size * size * size;
      }

      function getMathMulFrameFromStep(stepIndex, size) {
        const totalSteps = getMathMulTotalSteps(size);
        const clamped = Math.max(0, Math.min(totalSteps - 1, Number(stepIndex) || 0));
        const cellIndex = Math.floor(clamped / size);
        const row = Math.floor(cellIndex / size);
        const col = cellIndex % size;
        const term = clamped % size;
        return {
          done: clamped >= totalSteps - 1,
          stepIndex: clamped,
          row,
          col,
          term
        };
      }

      function getMathMulAnimationFrame() {
        if (!mathMulAnimation) return null;
        const stepDuration = mathMulAnimation.cellDurationMs / mathMulAnimation.size;
        const totalSteps = getMathMulTotalSteps(mathMulAnimation.size);
        const elapsed = performance.now() - mathMulAnimation.startTime;
        const stepIndex = Math.floor(elapsed / stepDuration);
        if (stepIndex >= totalSteps) {
          return getMathMulFrameFromStep(totalSteps - 1, mathMulAnimation.size);
        }
        return getMathMulFrameFromStep(stepIndex, mathMulAnimation.size);
      }

      function startMathMulAnimation(leftMatrix, rightMatrix, size, startStep = 0) {
        const clampedStart = Math.max(0, Math.min(getMathMulTotalSteps(size) - 1, Number(startStep) || 0));
        const stepDuration = 520 / size;
        mathMulAnimation = {
          startTime: performance.now() - clampedStart * stepDuration,
          cellDurationMs: 520,
          size,
          leftRowMajor: size === 3 ? toRowMajor3FromMatrix4(leftMatrix) : getRowMajorFromMatrix(leftMatrix),
          rightRowMajor: size === 3 ? toRowMajor3FromMatrix4(rightMatrix) : getRowMajorFromMatrix(rightMatrix)
        };
        mathMulManualSize = size;
        mathMulLastRenderedStep = -1;
      }

      function stopMathMulAnimation() {
        mathMulAnimation = null;
        mathMulLastRenderedStep = -1;
      }

      function renderMathMulAnimationCard(leftRowMajor, rightRowMajor, size) {
        const isPlaying = Boolean(mathMulAnimation);
        const frame = isPlaying ? getMathMulAnimationFrame() : getMathMulFrameFromStep(mathMulManualStep, size);
        const totalSteps = getMathMulTotalSteps(size);
        const resultRowMajor = multiplyRowMajor(leftRowMajor, rightRowMajor, size);
        const activeRow = frame ? frame.row : -1;
        const activeCol = frame ? frame.col : -1;
        const activeTerm = frame ? frame.term : -1;
        let details = '<p class="math-anim-eq">Press "Animate Multiplication" to show row-by-column calculation.</p>';

        if (frame) {
          const terms = [];
          let partial = 0;
          for (let k = 0; k < size; k += 1) {
            const a = leftRowMajor[activeRow * size + k];
            const b = rightRowMajor[k * size + activeCol];
            const mul = a * b;
            if (k <= activeTerm) partial += mul;
            const cls = k < activeTerm
              ? "math-dot-term math-dot-term-done"
              : k === activeTerm
                ? "math-dot-term math-dot-term-active"
                : "math-dot-term";
            terms.push(`<span class="${cls}">${formatValue(a)} * ${formatValue(b)} = ${formatValue(mul)}</span>`);
          }
          details = `
            <p class="math-anim-eq">r${activeRow + 1}, c${activeCol + 1}: partial = ${formatValue(partial)} | final = ${formatValue(resultRowMajor[activeRow * size + activeCol])}</p>
            <div class="math-dot-terms">${terms.join("")}</div>
          `;
        }

        return `
          <div class="math-card">
            <div class="math-anim-head">
              <p class="math-anim-label">Matrix Multiplication Animation</p>
              <button type="button" data-action="toggle-math-mul-animation">${isPlaying ? "Stop Animation" : "Play Animation"}</button>
            </div>
            ${details}
            <div class="math-anim-scrub">
              <label class="math-anim-label" for="mathMulStepRange">Step ${frame.stepIndex + 1} / ${totalSteps}</label>
              <input id="mathMulStepRange" type="range" min="0" max="${totalSteps - 1}" step="1" value="${frame.stepIndex}" data-action="math-mul-slider" />
            </div>
            <div class="math-anim-grid">
              <div class="math-anim-mats">
                <div class="math-anim-mat">
                  <p class="math-anim-mat-title">Left Matrix (rows)</p>
                  ${matrixToHtmlTable(leftRowMajor, { activeRow, size })}
                </div>
                <div class="math-anim-mat">
                  <p class="math-anim-mat-title">Right Matrix (columns)</p>
                  ${matrixToHtmlTable(rightRowMajor, { activeCol, size })}
                </div>
                <div class="math-anim-mat">
                  <p class="math-anim-mat-title">Result Matrix</p>
                  ${matrixToHtmlTable(resultRowMajor, {
                    size,
                    activeCellRow: activeRow,
                    activeCellCol: activeCol
                  })}
                </div>
              </div>
            </div>
          </div>
        `;
      }

      function updateMathVisualizer() {
        if (!mathFormOutput) return;
        const mathSize = is2D ? 3 : 4;
        if (mathMulManualSize !== mathSize) {
          mathMulManualSize = mathSize;
          mathMulManualStep = 0;
        }
        const entityLabel = getActiveTransformLabel();
        const currentMatrix = getGlobalTransformMatrix();
        const editorMatrix = tryReadMatrixFromInputs();
        let html = "";

        html += `
          <div class="math-card">
            <p class="math-label">${entityLabel}_current</p>
            ${matrixToHtmlTable(currentMatrix, { size: mathSize })}
          </div>
        `;

        if (editorMatrix) {
          const nextMatrix = currentMatrix.clone().multiply(editorMatrix);
          if (mathMulAnimation && mathMulAnimation.size !== mathSize) {
            stopMathMulAnimation();
          }
          const leftRowMajor = mathMulAnimation
            ? mathMulAnimation.leftRowMajor
            : (mathSize === 3 ? toRowMajor3FromMatrix4(currentMatrix) : getRowMajorFromMatrix(currentMatrix));
          const rightRowMajor = mathMulAnimation
            ? mathMulAnimation.rightRowMajor
            : (mathSize === 3 ? toRowMajor3FromMatrix4(editorMatrix) : getRowMajorFromMatrix(editorMatrix));
          html += `
            <div class="math-card">
              <p class="math-label">M_editor</p>
              ${matrixToHtmlTable(editorMatrix, { size: mathSize })}
            </div>
            <div class="math-card">
              <p class="math-equation">${entityLabel}_next = ${entityLabel}_current * M_editor</p>
              ${matrixToHtmlTable(nextMatrix, { size: mathSize })}
            </div>
            ${renderMathMulAnimationCard(leftRowMajor, rightRowMajor, mathSize)}
          `;
        } else {
          stopMathMulAnimation();
          html += `
            <div class="math-card">
              <p class="math-label">M_editor</p>
              <p class="math-equation">Invalid matrix input.</p>
            </div>
          `;
        }

        if (appliedMatrices.length === 0) {
          html += `
            <div class="math-card">
              <p class="math-equation">M_total = I</p>
            </div>
          `;
        } else {
          const chainTerms = appliedMatrices.map((entry) => `M${entry.id}`);
          const steps = [];
          for (let i = 0; i < appliedMatrices.length; i += 1) {
            const prev = i === 0 ? "I" : `S${i}`;
            const next = `S${i + 1}`;
            steps.push(`${next} = ${prev} * M${appliedMatrices[i].id}`);
          }
          const chainMatrix = new THREE.Matrix4();
          chainMatrix.identity();
          for (const entry of appliedMatrices) {
            chainMatrix.multiply(matrixFromRowMajor(entry.rowMajor));
          }
          html += `
            <div class="math-card">
              <p class="math-equation">M_total = I * ${chainTerms.join(" * ")}</p>
              <pre class="math-steps">${steps.join("\n")}</pre>
              ${matrixToHtmlTable(chainMatrix, { size: mathSize })}
            </div>
          `;
        }

        mathFormOutput.innerHTML = html;
      }

      function showOperationOutput(lines) {
        if (!operationOutput) return;
        operationOutput.textContent = Array.isArray(lines) ? lines.join("\n") : String(lines || "");
      }

      function formatVec3(v) {
        return `(${formatValue(v.x)}, ${formatValue(v.y)}, ${formatValue(v.z)})`;
      }

      function matrixFromRowMajor(rowMajor) {
        const m = new THREE.Matrix4();
        m.set(
          rowMajor[0], rowMajor[1], rowMajor[2], rowMajor[3],
          rowMajor[4], rowMajor[5], rowMajor[6], rowMajor[7],
          rowMajor[8], rowMajor[9], rowMajor[10], rowMajor[11],
          rowMajor[12], rowMajor[13], rowMajor[14], rowMajor[15]
        );
        return m;
      }

      function get2DComponentsFromMatrix(m) {
        const r = getRowMajorFromMatrix(m);
        return {
          a: r[0],
          b: r[1],
          tx: r[3],
          c: r[4],
          d: r[5],
          ty: r[7]
        };
      }

      function build2DMatrix({ a, b, tx, c, d, ty }) {
        const m = new THREE.Matrix4();
        m.set(
          a, b, 0, tx,
          c, d, 0, ty,
          0, 0, 1, 0,
          0, 0, 0, 1
        );
        return m;
      }

      function updateVizAxisReadout(matrix) {
        const { a, b, tx, c, d, ty } = get2DComponentsFromMatrix(matrix);
        const xTipX = tx + a;
        const xTipY = ty + c;
        const yTipX = tx + b;
        const yTipY = ty + d;
        if (vizTrigMode) {
          const sx = Math.hypot(a, c);
          const sy = Math.hypot(b, d);
          const theta = Math.atan2(c, a);
          const thetaDeg = (theta * 180) / Math.PI;
          vizAxisText.textContent = `origin = (${formatValue(tx)}, ${formatValue(ty)})
translation point = (${formatValue(tx)}, ${formatValue(ty)})
x_tip (grid) = (${formatValue(xTipX)}, ${formatValue(xTipY)})
y_tip (grid) = (${formatValue(yTipX)}, ${formatValue(yTipY)})

theta = ${formatValue(thetaDeg)} deg (${formatValue(theta)} rad)
sx = ${formatValue(sx)}, sy = ${formatValue(sy)}

2D basis (rotation/scale form):
x_axis = sx * (cos(theta), sin(theta))
y_axis = sy * (-sin(theta), cos(theta))

expanded:
a = sx*cos(theta) = ${formatValue(a)}
b = -sy*sin(theta) = ${formatValue(b)}
c = sx*sin(theta) = ${formatValue(c)}
d = sy*cos(theta) = ${formatValue(d)}`;
          return;
        }
        vizAxisText.textContent = `origin = (${formatValue(tx)}, ${formatValue(ty)})
x_axis = (${formatValue(a)}, ${formatValue(c)})
y_axis = (${formatValue(b)}, ${formatValue(d)})

translation point = (${formatValue(tx)}, ${formatValue(ty)})
x_tip (grid) = (${formatValue(xTipX)}, ${formatValue(xTipY)})
y_tip (grid) = (${formatValue(yTipX)}, ${formatValue(yTipY)})`;
      }

      function setVizLabel(el, text, worldPos) {
        if (!el || !worldPos) return;
        const projected = worldPos.clone().project(activeCamera);
        const visible = projected.z >= -1 && projected.z <= 1;
        if (!visible) {
          el.classList.add("hidden");
          return;
        }
        const x = (projected.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-projected.y * 0.5 + 0.5) * window.innerHeight;
        el.textContent = text;
        el.style.left = `${x}px`;
        el.style.top = `${y}px`;
        el.classList.remove("hidden");
      }

      function hideWorldAxisLabels() {
        worldAxisLabelX.classList.add("hidden");
        worldAxisLabelY.classList.add("hidden");
        worldAxisLabelZ.classList.add("hidden");
      }

      function updateWorldAxisLabels() {
        if (toolMode !== "transform") {
          hideWorldAxisLabels();
          return;
        }
        setVizLabel(worldAxisLabelX, "X axis", new THREE.Vector3(4.4, 0, 0));
        setVizLabel(worldAxisLabelY, "Y axis", new THREE.Vector3(0, 4.4, 0));
        if (is2D) {
          worldAxisLabelZ.classList.add("hidden");
        } else {
          setVizLabel(worldAxisLabelZ, "Z axis", new THREE.Vector3(0, 0, 4.4));
        }
      }

      function hideVizLabels() {
        vizLabelOrigin.classList.add("hidden");
        vizLabelX.classList.add("hidden");
        vizLabelY.classList.add("hidden");
      }

      function updatePointWorldViz() {
        if (toolMode !== "transform" || transformEntityMode !== "point") {
          pointWorldVizGroup.visible = false;
          pointWorldLabel.classList.add("hidden");
          return;
        }
        const pointPos = new THREE.Vector3().setFromMatrixPosition(point.matrix);
        const origin = new THREE.Vector3(0, 0, 0);
        const projected = new THREE.Vector3(pointPos.x, pointPos.y, 0);

        pointWorldPath.geometry.setFromPoints([origin, pointPos]);
        pointWorldPath.computeLineDistances();
        pointWorldProjection.geometry.setFromPoints([pointPos, projected]);
        pointWorldProjection.computeLineDistances();
        pointWorldProjectedDot.position.copy(projected);
        pointWorldVizGroup.visible = true;

        setVizLabel(
          pointWorldLabel,
          `P (${formatValue(pointPos.x)}, ${formatValue(pointPos.y)}, ${formatValue(pointPos.z)})`,
          pointPos
        );
      }

      function updateVizHandleLabels() {
        if (toolMode !== "viz") {
          hideVizLabels();
          return;
        }
        const matrix = tryReadMatrixFromInputs();
        if (!matrix) {
          hideVizLabels();
          return;
        }
        const { a, b, tx, c, d, ty } = get2DComponentsFromMatrix(matrix);
        const origin = new THREE.Vector3(tx, ty, 0);
        const xTip = new THREE.Vector3(tx + a, ty + c, 0);
        const yTip = new THREE.Vector3(tx + b, ty + d, 0);
        setVizLabel(vizLabelOrigin, `O (${formatValue(tx)}, ${formatValue(ty)})`, origin);
        setVizLabel(vizLabelX, `X (${formatValue(xTip.x)}, ${formatValue(xTip.y)})`, xTip);
        setVizLabel(vizLabelY, `Y (${formatValue(yTip.x)}, ${formatValue(yTip.y)})`, yTip);
      }

      function getAppliedMatrixDisplayData() {
        const accumulated = chainBaseMatrix.clone();
        return appliedMatrices.map((entry) => {
          const m = matrixFromRowMajor(entry.rowMajor);
          const localTranslation = new THREE.Vector3().setFromMatrixPosition(m);
          accumulated.multiply(m);
          const cumulativeTranslation = new THREE.Vector3().setFromMatrixPosition(accumulated);
          return {
            ...entry,
            localTranslation,
            cumulativeTranslation
          };
        });
      }

      function getAppliedChainData() {
        const steps = [];
        const accumulated = chainBaseMatrix.clone();
        for (let i = 0; i < appliedMatrices.length; i += 1) {
          const local = matrixFromRowMajor(appliedMatrices[i].rowMajor);
          const prefix = accumulated.clone();
          accumulated.multiply(local);
          const cumulative = accumulated.clone();
          steps.push({
            index: i,
            local,
            prefix,
            cumulative
          });
        }
        return steps;
      }

      function getAppliedProductMatrix() {
        const product = new THREE.Matrix4();
        product.identity();
        for (const entry of appliedMatrices) {
          product.multiply(matrixFromRowMajor(entry.rowMajor));
        }
        return product;
      }

      function rebaseAppliedChainToCurrent(currentMatrix) {
        if (appliedMatrices.length === 0) {
          chainBaseMatrix = currentMatrix.clone();
          return;
        }
        const product = getAppliedProductMatrix();
        if (Math.abs(product.determinant()) < 1e-8) {
          return;
        }
        product.invert();
        chainBaseMatrix = currentMatrix.clone().multiply(product);
      }

      function recomputeFinalFromAppliedChain() {
        const result = chainBaseMatrix.clone();
        for (const entry of appliedMatrices) {
          result.multiply(matrixFromRowMajor(entry.rowMajor));
        }
        setActiveTransformMatrix(result);
        scrubStartMatrix = getGlobalTransformMatrix();
      }

      function buildChainKeyframes(extraRowMajor) {
        const keyframes = [];
        const cumulative = chainBaseMatrix.clone();
        keyframes.push(cumulative.clone());

        for (const entry of appliedMatrices) {
          cumulative.multiply(matrixFromRowMajor(entry.rowMajor));
          keyframes.push(cumulative.clone());
        }

        if (extraRowMajor) {
          cumulative.multiply(matrixFromRowMajor(extraRowMajor));
          keyframes.push(cumulative.clone());
        }

        return keyframes;
      }

      function renderTranslationViz() {
        translationVizGroup.clear();

        const origin = new THREE.Mesh(
          new THREE.SphereGeometry(0.12, 12, 12),
          new THREE.MeshBasicMaterial({ color: 0xffffff })
        );
        origin.position.set(0, 0, 0);
        translationVizGroup.add(origin);

        const steps = getAppliedChainData();
        const points = [new THREE.Vector3(0, 0, 0)];

        for (let i = 0; i < steps.length; i += 1) {
          const isSelected = selectedAppliedStepIndex === i;
          const pos = new THREE.Vector3();
          const quat = new THREE.Quaternion();
          const scl = new THREE.Vector3();
          steps[i].cumulative.decompose(pos, quat, scl);
          points.push(pos.clone());

          const marker = new THREE.Group();
          marker.position.copy(pos);
          marker.quaternion.copy(quat);
          marker.userData.stepIndex = i;
          marker.userData.kind = "chain-point";

          const axis = new THREE.AxesHelper(isSelected ? 0.85 : 0.65);
          marker.add(axis);

          const hitTarget = new THREE.Mesh(
            new THREE.SphereGeometry(isSelected ? 0.18 : 0.16, 12, 12),
            new THREE.MeshBasicMaterial({
              color: isSelected ? 0xffd166 : 0xffffff,
              transparent: true,
              opacity: isSelected ? 0.35 : 0.05,
              depthWrite: false
            })
          );
          hitTarget.userData.stepIndex = i;
          hitTarget.userData.kind = "chain-point";
          marker.add(hitTarget);

          translationVizGroup.add(marker);
        }

        // While an interpolated multiply is running, preview its in-flight translation path.
        if (interpolation && interpolation.historyRowMajor) {
          const previewPos = new THREE.Vector3().setFromMatrixPosition(getActiveTransformObject().matrix);
          const last = points[points.length - 1];
          if (last.distanceToSquared(previewPos) > 1e-8) {
            points.push(previewPos.clone());
          }
          const previewMarker = new THREE.Mesh(
            new THREE.SphereGeometry(0.12, 10, 10),
            new THREE.MeshBasicMaterial({ color: 0x7dd3fc, transparent: true, opacity: 0.6 })
          );
          previewMarker.position.copy(previewPos);
          translationVizGroup.add(previewMarker);
        }

        if (points.length < 2) return;

        const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(
          lineGeometry,
          new THREE.LineDashedMaterial({
            color: 0xffa84d,
            dashSize: 0.3,
            gapSize: 0.2,
            transparent: true,
            opacity: 0.4
          })
        );
        line.computeLineDistances();
        translationVizGroup.add(line);
      }

      const appliedMatrices = [];
      let nextAppliedId = 1;

      function refreshChainStepSelect() {
        const previous = selectedAppliedStepIndex;
        chainStepSelect.innerHTML = '<option value="">Edit Step: None</option>';
        for (let i = 0; i < appliedMatrices.length; i += 1) {
          const option = document.createElement("option");
          option.value = String(i);
          option.textContent = `Edit M${appliedMatrices[i].id}`;
          chainStepSelect.appendChild(option);
        }
        if (previous >= 0 && previous < appliedMatrices.length) {
          selectedAppliedStepIndex = previous;
          chainStepSelect.value = String(previous);
        } else {
          selectedAppliedStepIndex = -1;
          chainStepSelect.value = "";
        }
      }

      function renderAppliedMatrices() {
        const displayData = getAppliedMatrixDisplayData();
        if (appliedMatrices.length === 0) {
          appliedMatrixList.className = "applied-empty";
          appliedMatrixList.textContent = "No matrices applied yet.";
          renderTranslationViz();
          refreshChainStepSelect();
          syncChainControlAttachment();
          updateMathVisualizer();
          return;
        }

        appliedMatrixList.className = "";
        appliedMatrixList.innerHTML = displayData
          .map(
            (entry) => `
              <details class="applied-item">
                <summary>M${entry.id} (multiply)</summary>
                <pre>local T: ${formatVec3(entry.localTranslation)}
cumulative T: ${formatVec3(entry.cumulativeTranslation)}</pre>
                <button type="button" data-load-matrix="${entry.id}">Load to Editor</button>
                <pre>${toRowMajorText(entry.rowMajor)}</pre>
              </details>
            `
          )
          .join("");
        renderTranslationViz();
        refreshChainStepSelect();
        syncChainControlAttachment();
        updateMathVisualizer();
      }

      function addAppliedMatrix(rowMajor, baseMatrix) {
        if (appliedMatrices.length === 0 && baseMatrix instanceof THREE.Matrix4) {
          chainBaseMatrix = baseMatrix.clone();
        }
        appliedMatrices.push({
          id: nextAppliedId,
          rowMajor: [...rowMajor]
        });
        nextAppliedId += 1;
        renderAppliedMatrices();
      }

      function renderMatrixVizFromCurrentEditor() {
        matrixVizGroup.clear();
        matrixVizHandles = { origin: null, x: null, y: null };
        const matrix = tryReadMatrixFromInputs();
        if (!matrix) {
          vizAxisText.textContent = "Invalid matrix input.";
          hideVizLabels();
          return;
        }

        const origin = new THREE.Vector3(0, 0, 0).applyMatrix4(matrix);
        const xPoint = new THREE.Vector3(1, 0, 0).applyMatrix4(matrix);
        const yPoint = new THREE.Vector3(0, 1, 0).applyMatrix4(matrix);
        const xDir = xPoint.clone().sub(origin);
        const yDir = yPoint.clone().sub(origin);

        const originDot = new THREE.Mesh(
          new THREE.SphereGeometry(0.18, 14, 14),
          new THREE.MeshBasicMaterial({ color: 0xffffff })
        );
        originDot.userData.dragRole = "origin";
        originDot.position.copy(origin);
        matrixVizGroup.add(originDot);
        matrixVizHandles.origin = originDot;

        if (xDir.lengthSq() > 1e-8) {
          const xArrow = new THREE.ArrowHelper(
            xDir.clone().normalize(),
            origin,
            xDir.length(),
            0xff4d4d,
            0.35,
            0.2
          );
          matrixVizGroup.add(xArrow);
          const xHandle = new THREE.Mesh(
            new THREE.SphereGeometry(0.14, 12, 12),
            new THREE.MeshBasicMaterial({ color: 0xff4d4d })
          );
          xHandle.userData.dragRole = "x";
          xHandle.position.copy(xPoint);
          matrixVizGroup.add(xHandle);
          matrixVizHandles.x = xHandle;
        }
        if (yDir.lengthSq() > 1e-8) {
          const yArrow = new THREE.ArrowHelper(
            yDir.clone().normalize(),
            origin,
            yDir.length(),
            0x55d26a,
            0.35,
            0.2
          );
          matrixVizGroup.add(yArrow);
          const yHandle = new THREE.Mesh(
            new THREE.SphereGeometry(0.14, 12, 12),
            new THREE.MeshBasicMaterial({ color: 0x55d26a })
          );
          yHandle.userData.dragRole = "y";
          yHandle.position.copy(yPoint);
          matrixVizGroup.add(yHandle);
          matrixVizHandles.y = yHandle;
        }
        updateVizAxisReadout(matrix);
        updateVizHandleLabels();
      }

      function setToolMode(nextMode) {
        if (toolMode === nextMode) return;

        const currentEditorMatrix = tryReadMatrixFromInputs() || getGlobalTransformMatrix();
        if (toolMode === "transform") {
          transformEditorMatrix = currentEditorMatrix.clone();
        } else {
          vizEditorMatrix = currentEditorMatrix.clone();
        }

        toolMode = nextMode;
        const inViz = toolMode === "viz";

        if (inViz) {
          stopInterpolationNow();
          dragState = null;
          if (!vizEditorMatrix) vizEditorMatrix = createIdentityMatrix();
          is2D = true;
          activeCamera = camera2D;
          gridXY.visible = true;
          gridXZ.visible = false;
          gridYZ.visible = false;
          createControls(activeCamera, true);
          modeLabel.textContent = "Mode: 2D";
          modeToggle.textContent = "Switch to 3D";
          modeToggle.disabled = true;

          syncTransformEntityVisibility();
          translationVizGroup.visible = false;
          matrixVizGroup.visible = true;
          appliedSection.classList.add("hidden");
          vizHint.classList.remove("hidden");
          vizAxisReadout.classList.remove("hidden");
          if (chainControl) {
            chainControl.detach();
            chainControl.visible = false;
          }

          rebuildMatrixEditor("2d", vizEditorMatrix);
          renderMatrixVizFromCurrentEditor();
          for (const control of transformControls) control.disabled = true;
          toolModeLabel.textContent = "Tool: Matrix Viz";
          toolModeToggle.textContent = "Transform Tool";
          matrixStatus.textContent = "Visualization mode active.";
          return;
        }

        modeToggle.disabled = false;
        syncTransformEntityVisibility();
        translationVizGroup.visible = true;
        matrixVizGroup.visible = false;
        appliedSection.classList.remove("hidden");
        vizHint.classList.add("hidden");
        vizAxisReadout.classList.add("hidden");

        is2D = transformViewIs2D;
        const restoreMode = is2D ? "2d" : "3d";
        rebuildMatrixEditor(restoreMode, transformEditorMatrix || getGlobalTransformMatrix());
        gridXY.visible = true;
        gridXZ.visible = !is2D;
        gridYZ.visible = !is2D;
        activeCamera = is2D ? camera2D : camera3D;
        createControls(activeCamera, is2D);
        for (const control of transformControls) control.disabled = false;
        modeLabel.textContent = `Mode: ${is2D ? "2D" : "3D"}`;
        modeToggle.textContent = is2D ? "Switch to 3D" : "Switch to 2D";
        toolModeLabel.textContent = "Tool: Transform";
        toolModeToggle.textContent = "Matrix Viz";
        matrixStatus.textContent = "Transform mode active.";
        hideVizLabels();
        syncChainControlAttachment();
      }

      function onMatrixEditorInputChanged() {
        if (toolMode === "viz") {
          renderMatrixVizFromCurrentEditor();
          updateMathVisualizer();
          return;
        }
        updateMathVisualizer();
      }

      function getPointerNdcFromEvent(event) {
        const rect = renderer.domElement.getBoundingClientRect();
        pointerNdc.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        pointerNdc.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      }

      function getWorldPointOnVizPlane(event) {
        getPointerNdcFromEvent(event);
        raycaster.setFromCamera(pointerNdc, activeCamera);
        const hit = new THREE.Vector3();
        if (!raycaster.ray.intersectPlane(dragPlane, hit)) return null;
        return hit;
      }

      function applyVizDragPoint(role, worldPoint) {
        const matrix = tryReadMatrixFromInputs();
        if (!matrix) return;
        const comp = get2DComponentsFromMatrix(matrix);
        if (role === "origin") {
          comp.tx = worldPoint.x;
          comp.ty = worldPoint.y;
        } else if (role === "x") {
          comp.a = worldPoint.x - comp.tx;
          comp.c = worldPoint.y - comp.ty;
        } else if (role === "y") {
          comp.b = worldPoint.x - comp.tx;
          comp.d = worldPoint.y - comp.ty;
        } else {
          return;
        }
        const next = build2DMatrix(comp);
        setInputsFromMatrix(next);
        renderMatrixVizFromCurrentEditor();
      }

      function onVizPointerDown(event) {
        if (toolMode === "transform") {
          const stepMarkers = translationVizGroup.children.filter(
            (obj) => obj.userData && obj.userData.kind === "chain-point"
          );
          if (stepMarkers.length > 0) {
            getPointerNdcFromEvent(event);
            raycaster.setFromCamera(pointerNdc, activeCamera);
            const stepHits = raycaster.intersectObjects(stepMarkers, true);
            if (stepHits.length > 0) {
              let hitObj = stepHits[0].object;
              while (hitObj && (!hitObj.userData || !Number.isInteger(hitObj.userData.stepIndex))) {
                hitObj = hitObj.parent;
              }
              const hitStep = hitObj && hitObj.userData ? hitObj.userData.stepIndex : null;
              if (Number.isInteger(hitStep)) {
                selectedAppliedStepIndex = hitStep;
                chainStepSelect.value = String(hitStep);
                renderAppliedMatrices();
                syncChainControlAttachment();
                matrixStatus.textContent = `Selected step M${appliedMatrices[hitStep].id}.`;
                return;
              }
            }
          }
          return;
        }
        if (toolMode !== "viz") return;
        const handles = [matrixVizHandles.origin, matrixVizHandles.x, matrixVizHandles.y].filter(Boolean);
        if (handles.length === 0) return;
        getPointerNdcFromEvent(event);
        raycaster.setFromCamera(pointerNdc, activeCamera);
        const hits = raycaster.intersectObjects(handles, false);
        if (hits.length === 0) return;
        const role = hits[0].object.userData.dragRole;
        if (!role) return;
        dragState = { dragMode: "viz", role };
        controls.enabled = false;
        renderer.domElement.setPointerCapture(event.pointerId);
      }

      function onVizPointerMove(event) {
        if (!dragState) return;
        const point = getWorldPointOnVizPlane(event);
        if (!point) return;
        if (dragState.dragMode === "viz") {
          if (toolMode !== "viz") return;
          applyVizDragPoint(dragState.role, point);
          return;
        }
      }

      function onVizPointerUp(event) {
        if (!dragState) return;
        dragState = null;
        controls.enabled = true;
        try {
          renderer.domElement.releasePointerCapture(event.pointerId);
        } catch {
          // no-op
        }
      }

      transformEditorMatrix = createIdentityMatrix();
      vizEditorMatrix = createIdentityMatrix();
      gridXY.visible = true;
      gridXZ.visible = !is2D;
      gridYZ.visible = !is2D;
      createControls(activeCamera, is2D);
      rebuildMatrixEditor("2d", transformEditorMatrix);
      syncChainControlModeButtons();
      resetCube.textContent = "Reset Point";
      syncTransformEntityVisibility();
      updateCurrentStatePanel();
      renderAppliedMatrices();
      initPanelToggles();

      function readMatrixFromInputs() {
        const nums = matrixInputs.map((input) => evaluateCellExpression(input.value));
        for (const value of nums) {
          if (!Number.isFinite(value)) {
            throw new Error("Matrix has invalid numeric value.");
          }
        }
        if (editorMode === "2d") {
          const m2d = new THREE.Matrix4();
          m2d.set(
            nums[0], nums[1], 0, nums[2],
            nums[3], nums[4], 0, nums[5],
            0, 0, 1, 0,
            nums[6], nums[7], 0, nums[8]
          );
          return m2d;
        }
        const m = new THREE.Matrix4();
        m.set(
          nums[0], nums[1], nums[2], nums[3],
          nums[4], nums[5], nums[6], nums[7],
          nums[8], nums[9], nums[10], nums[11],
          nums[12], nums[13], nums[14], nums[15]
        );
        return m;
      }

      function evaluateCellExpression(raw) {
        const text = String(raw || "").trim().toLowerCase();
        if (!text) {
          throw new Error("Matrix cell cannot be empty.");
        }

        // Allow only numbers, operators, whitespace, parentheses, commas, and known identifiers.
        if (/[^0-9a-z+\-*/^().,\s]/i.test(text)) {
          throw new Error(`Invalid characters in expression: ${raw}`);
        }

        let expr = text;
        expr = expr.replace(/\bpi\b/g, "Math.PI");
        expr = expr.replace(/\be\b/g, "Math.E");
        expr = expr.replace(/\^/g, "**");
        expr = expr.replace(/\b(sin|cos|tan)\s+([^\s][^,]*)/g, "Math.$1($2)");
        expr = expr.replace(/\b(sin|cos|tan)\s*\(/g, "$1(");
        expr = expr.replace(/\bmath\.(sin|cos|tan)\s*\(/g, "$1(");

        if (/[^0-9+\-*/().,\s*a-zA-Z_]/.test(expr)) {
          throw new Error(`Expression not allowed: ${raw}`);
        }
        const identifiers = expr.match(/[a-zA-Z_][a-zA-Z0-9_]*/g) || [];
        const allowed = new Set(["Math", "PI", "E", "sin", "cos", "tan"]);
        for (const id of identifiers) {
          if (!allowed.has(id)) {
            throw new Error(`Unknown token in expression: ${id}`);
          }
        }

        let value;
        try {
          value = Function(
            `"use strict";
const sin = (deg) => Math.sin((deg * Math.PI) / 180);
const cos = (deg) => Math.cos((deg * Math.PI) / 180);
const tan = (deg) => Math.tan((deg * Math.PI) / 180);
return (${expr});`
          )();
        } catch {
          throw new Error(`Invalid expression: ${raw}`);
        }
        if (!Number.isFinite(value)) {
          throw new Error(`Expression not finite: ${raw}`);
        }
        return value;
      }

      function applyInterpolatedMatrix(startMatrix, endMatrix, t) {
        const aPos = new THREE.Vector3();
        const aQuat = new THREE.Quaternion();
        const aScale = new THREE.Vector3();
        const bPos = new THREE.Vector3();
        const bQuat = new THREE.Quaternion();
        const bScale = new THREE.Vector3();
        startMatrix.decompose(aPos, aQuat, aScale);
        endMatrix.decompose(bPos, bQuat, bScale);

        const pos = aPos.lerp(bPos, t);
        const quat = aQuat.slerp(bQuat, t);
        const scale = aScale.lerp(bScale, t);
        const out = new THREE.Matrix4().compose(pos, quat, scale);
        setActiveTransformMatrix(out);
      }

      function getEasedT(t) {
        return t * t * (3 - 2 * t);
      }

      let scrubStartMatrix = getGlobalTransformMatrix();

      function stopInterpolationNow() {
        interpolation = null;
      }

      function completeInterpolationNow() {
        if (!interpolation) return false;
        const done = interpolation;
        applyInterpolatedMatrix(done.startMatrix, done.endMatrix, 1);
        interpolation = null;
        matrixStatus.textContent = done.completeMessage || "Interpolation complete.";
        if (done.historyRowMajor) addAppliedMatrix(done.historyRowMajor, done.startMatrix);
        scrubStartMatrix = getGlobalTransformMatrix();
        showOperationOutput([
          "Edited / Current Chain Result:",
          "",
          `${getActiveTransformLabel()} current:`,
          matrixToText(getActiveTransformObject().matrix)
        ]);
        return true;
      }

      applyMatrix.addEventListener("click", () => {
        try {
          stopInterpolationNow();
          const inputMatrix = readMatrixFromInputs();
          const rowMajor = getRowMajorFromMatrix(inputMatrix);
          const durationMs = INTERP_DURATION_MS;
          const entityLabel = getActiveTransformLabel();
          const startMatrix = getGlobalTransformMatrix();
          const endMatrix = startMatrix.clone().multiply(inputMatrix);
          showOperationOutput([
            `${entityLabel}_next = ${entityLabel}_current * M_editor`,
            "",
            `${entityLabel}_current:`,
            matrixToText(startMatrix),
            "",
            "M_editor:",
            matrixToText(inputMatrix),
            "",
            `${entityLabel}_next:`,
            matrixToText(endMatrix)
          ]);
          interpolation = {
            startMatrix,
            endMatrix,
            startTime: performance.now(),
            durationMs,
            completeMessage: "Multiply interpolation complete.",
            historyRowMajor: rowMajor
          };
          matrixStatus.textContent = "Interpolating multiply...";
          scrubStartMatrix = startMatrix.clone();
        } catch (err) {
          matrixStatus.textContent = err instanceof Error ? err.message : "Invalid matrix input.";
        }
      });

      directMultiply.addEventListener("click", () => {
        try {
          stopInterpolationNow();
          const inputMatrix = readMatrixFromInputs();
          const rowMajor = getRowMajorFromMatrix(inputMatrix);
          const entityLabel = getActiveTransformLabel();
          const current = getGlobalTransformMatrix();
          const next = current.clone().multiply(inputMatrix);
          setActiveTransformMatrix(next);
          addAppliedMatrix(rowMajor, current);
          showOperationOutput([
            `${entityLabel}_next = ${entityLabel}_current * M_editor (direct)`,
            "",
            `${entityLabel}_current:`,
            matrixToText(current),
            "",
            "M_editor:",
            matrixToText(inputMatrix),
            "",
            `${entityLabel}_next:`,
            matrixToText(next)
          ]);
          matrixStatus.textContent = "Direct multiply applied.";
          scrubStartMatrix = getGlobalTransformMatrix();
        } catch (err) {
          matrixStatus.textContent = err instanceof Error ? err.message : "Invalid matrix input.";
        }
      });

      revertByInverse.addEventListener("click", () => {
        try {
          stopInterpolationNow();
          const inputMatrix = readMatrixFromInputs();
          if (Math.abs(inputMatrix.determinant()) < 1e-8) {
            throw new Error("Matrix is not invertible.");
          }
          const inverse = inputMatrix.clone();
          inverse.invert();
          const inverseRowMajor = getRowMajorFromMatrix(inverse);
          const entityLabel = getActiveTransformLabel();
          const current = getGlobalTransformMatrix();
          const next = current.clone().multiply(inverse);
          setActiveTransformMatrix(next);
          addAppliedMatrix(inverseRowMajor, current);
          showOperationOutput([
            `${entityLabel}_next = ${entityLabel}_current * inv(M_editor)`,
            "",
            `${entityLabel}_current:`,
            matrixToText(current),
            "",
            "inv(M_editor):",
            matrixToText(inverse),
            "",
            `${entityLabel}_next:`,
            matrixToText(next)
          ]);
          matrixStatus.textContent = "Inverse multiply applied (revert).";
          scrubStartMatrix = getGlobalTransformMatrix();
        } catch (err) {
          matrixStatus.textContent = err instanceof Error ? err.message : "Invalid matrix input.";
        }
      });

      setMatrix.addEventListener("click", () => {
        try {
          const inputMatrix = readMatrixFromInputs();
          const entityLabel = getActiveTransformLabel();
          chainBaseMatrix = inputMatrix.clone();
          if (appliedMatrices.length > 0) {
            recomputeFinalFromAppliedChain();
          } else {
            setActiveTransformMatrix(inputMatrix);
          }
          renderAppliedMatrices();
          const finalCurrent = getGlobalTransformMatrix();
          showOperationOutput([
            `${entityLabel} = M_editor`,
            "",
            "M_editor:",
            matrixToText(inputMatrix),
            "",
            `${entityLabel}:`,
            matrixToText(finalCurrent)
          ]);
          matrixStatus.textContent = `Applied: ${entityLabel} = M`;
          scrubStartMatrix = finalCurrent.clone();
        } catch (err) {
          matrixStatus.textContent = err instanceof Error ? err.message : "Invalid matrix input.";
        }
      });

      copyCurrent.addEventListener("click", () => {
        setInputsFromMatrix(getGlobalTransformMatrix());
        matrixStatus.textContent = `Target matrix updated from current ${getActiveTransformLabel()} transform.`;
      });

      identityTarget.addEventListener("click", () => {
        setInputsFromMatrix(new THREE.Matrix4());
        matrixStatus.textContent = "Target matrix set to identity.";
      });

      replayTransformations.addEventListener("click", () => {
        try {
          stopInterpolationNow();
          const keyframes = buildChainKeyframes();
          if (keyframes.length <= 1) {
            matrixStatus.textContent = "No applied chain to replay yet.";
            return;
          }
          const durationMs = INTERP_DURATION_MS;
          const entityLabel = getActiveTransformLabel();
          showOperationOutput([
            `Replay Chain: ${entityLabel}(t) from I to chain result`,
            "",
            "I (identity):",
            matrixToText(keyframes[0]),
            "",
            "chain_result:",
            matrixToText(keyframes[keyframes.length - 1])
          ]);
          setActiveTransformMatrix(keyframes[0]);
          interpolation = {
            startMatrix: keyframes[0].clone(),
            endMatrix: keyframes[keyframes.length - 1].clone(),
            keyframes,
            startTime: performance.now(),
            durationMs,
            completeMessage: "Chain replay complete."
          };
          matrixStatus.textContent = "Replaying transformations step-by-step...";
        } catch (err) {
          matrixStatus.textContent = err instanceof Error ? err.message : "Invalid matrix input.";
        }
      });

      doTransformation.addEventListener("click", () => {
        try {
          stopInterpolationNow();
          const keyframes = buildChainKeyframes();
          if (keyframes.length <= 1) {
            matrixStatus.textContent = "No applied chain to run yet.";
            return;
          }
          const durationMs = INTERP_DURATION_MS;
          const start = keyframes[0].clone();
          const end = keyframes[keyframes.length - 1].clone();
          setActiveTransformMatrix(start);
          interpolation = {
            startMatrix: start,
            endMatrix: end,
            startTime: performance.now(),
            durationMs,
            completeMessage: "Transformation complete."
          };
          matrixStatus.textContent = "Applying full transformation...";
        } catch (err) {
          matrixStatus.textContent = err instanceof Error ? err.message : "Invalid matrix input.";
        }
      });

      resetCube.addEventListener("click", () => {
        stopInterpolationNow();
        const identity = createIdentityMatrix();
        if (transformEntityMode === "point") {
          pointBaseMatrix = createIdentityMatrix();
        }
        setActiveTransformMatrix(identity);
        setInputsFromMatrix(identity);
        const entityLabel = getActiveTransformLabel();
        showOperationOutput([
          "Reset:",
          "",
          `${entityLabel} = I`,
          "",
          "I (identity):",
          matrixToText(identity)
        ]);
        matrixStatus.textContent = `${entityLabel} reset to identity transform.`;
        appliedMatrices.length = 0;
        nextAppliedId = 1;
        chainBaseMatrix = createIdentityMatrix();
        renderAppliedMatrices();
        scrubStartMatrix = getGlobalTransformMatrix();
      });

      appliedMatrixList.addEventListener("click", (event) => {
        const target = event.target;
        if (!(target instanceof HTMLElement)) return;
        const idText = target.getAttribute("data-load-matrix");
        if (!idText) return;
        const id = Number(idText);
        const entry = appliedMatrices.find((item) => item.id === id);
        if (!entry) return;
        const m = new THREE.Matrix4();
        m.set(
          entry.rowMajor[0], entry.rowMajor[1], entry.rowMajor[2], entry.rowMajor[3],
          entry.rowMajor[4], entry.rowMajor[5], entry.rowMajor[6], entry.rowMajor[7],
          entry.rowMajor[8], entry.rowMajor[9], entry.rowMajor[10], entry.rowMajor[11],
          entry.rowMajor[12], entry.rowMajor[13], entry.rowMajor[14], entry.rowMajor[15]
        );
        setInputsFromMatrix(m);
        matrixStatus.textContent = `Loaded M${id} into editor.`;
      });

      modeToggle.addEventListener("click", () => {
        if (toolMode === "viz") return;
        let preservedEditorMatrix = createIdentityMatrix();
        try {
          preservedEditorMatrix = readMatrixFromInputs();
        } catch {
          preservedEditorMatrix = getGlobalTransformMatrix();
        }
        is2D = !is2D;
        transformViewIs2D = is2D;
        activeCamera = is2D ? camera2D : camera3D;

        gridXY.visible = true;
        gridXZ.visible = !is2D;
        gridYZ.visible = !is2D;
        rebuildMatrixEditor(is2D ? "2d" : "3d", preservedEditorMatrix);
        transformEditorMatrix = preservedEditorMatrix.clone();

        createControls(activeCamera, is2D);
        modeLabel.textContent = `Mode: ${is2D ? "2D" : "3D"}`;
        modeToggle.textContent = is2D ? "Switch to 3D" : "Switch to 2D";
      });

      transformObjectMode.addEventListener("change", () => {
        if (toolMode === "viz") return;
        stopInterpolationNow();
        transformEntityMode = transformObjectMode.value === "point" ? "point" : "cube";
        syncTransformEntityVisibility();
        const current = getGlobalTransformMatrix();
        setInputsFromMatrix(current);
        transformEditorMatrix = current.clone();
        resetCube.textContent = transformEntityMode === "point" ? "Reset Point" : "Reset Cube";
        matrixStatus.textContent = `Transform object set to ${getActiveTransformLabel()}.`;
        updateCurrentStatePanel();
        syncChainControlAttachment();
      });

      chainStepSelect.addEventListener("change", () => {
        const value = chainStepSelect.value;
        selectedAppliedStepIndex = value === "" ? -1 : Number(value);
        syncChainControlAttachment();
      });

      revertSelectedStep.addEventListener("click", () => {
        if (selectedAppliedStepIndex < 0 || selectedAppliedStepIndex >= appliedMatrices.length) {
          matrixStatus.textContent = "Select a matrix step first.";
          return;
        }
        try {
          const entry = appliedMatrices[selectedAppliedStepIndex];
          appliedMatrices.splice(selectedAppliedStepIndex, 1);
          selectedAppliedStepIndex = -1;
          chainStepSelect.value = "";
          recomputeFinalFromAppliedChain();
          renderAppliedMatrices();
          showOperationOutput([
            `Revert selected: removed M${entry.id} from applied chain.`,
            "",
            "Updated global matrix:",
            matrixToText(getGlobalTransformMatrix())
          ]);
          matrixStatus.textContent = `Removed M${entry.id} from chain.`;
          scrubStartMatrix = getGlobalTransformMatrix();
        } catch (err) {
          matrixStatus.textContent = err instanceof Error ? err.message : "Could not revert selected step.";
        }
      });

      chainModeTranslate.addEventListener("click", () => {
        chainControlMode = chainControlMode === "translate" ? "none" : "translate";
        syncChainControlModeButtons();
        syncChainControlAttachment();
      });
      chainModeRotate.addEventListener("click", () => {
        chainControlMode = chainControlMode === "rotate" ? "none" : "rotate";
        syncChainControlModeButtons();
        syncChainControlAttachment();
      });
      chainModeScale.addEventListener("click", () => {
        chainControlMode = chainControlMode === "scale" ? "none" : "scale";
        syncChainControlModeButtons();
        syncChainControlAttachment();
      });

      toolModeToggle.addEventListener("click", () => {
        setToolMode(toolMode === "transform" ? "viz" : "transform");
      });

      vizTrigToggle.addEventListener("click", () => {
        vizTrigMode = !vizTrigMode;
        vizTrigToggle.textContent = `Trig View: ${vizTrigMode ? "On" : "Off"}`;
        if (toolMode === "viz") {
          const current = tryReadMatrixFromInputs();
          if (current) {
            setInputsFromMatrix(current);
          }
          renderMatrixVizFromCurrentEditor();
        }
      });

      mathFormOutput.addEventListener("click", (event) => {
        const target = event.target;
        if (!(target instanceof HTMLElement)) return;
        if (target.getAttribute("data-action") !== "toggle-math-mul-animation") return;
        if (mathMulAnimation) {
          const frame = getMathMulAnimationFrame();
          if (frame) mathMulManualStep = frame.stepIndex;
          stopMathMulAnimation();
          updateMathVisualizer();
          return;
        }
        const editorMatrix = tryReadMatrixFromInputs();
        if (!editorMatrix) {
          matrixStatus.textContent = "Cannot animate: invalid matrix input.";
          return;
        }
        startMathMulAnimation(getGlobalTransformMatrix(), editorMatrix, is2D ? 3 : 4, mathMulManualStep);
        updateMathVisualizer();
      });

      mathFormOutput.addEventListener("input", (event) => {
        const target = event.target;
        if (!(target instanceof HTMLInputElement)) return;
        if (target.getAttribute("data-action") !== "math-mul-slider") return;
        const nextStep = Number(target.value);
        if (!Number.isFinite(nextStep)) return;
        mathMulManualStep = Math.max(0, Math.floor(nextStep));
        stopMathMulAnimation();
      });

      mathFormOutput.addEventListener("change", (event) => {
        const target = event.target;
        if (!(target instanceof HTMLInputElement)) return;
        if (target.getAttribute("data-action") !== "math-mul-slider") return;
        const nextStep = Number(target.value);
        if (!Number.isFinite(nextStep)) return;
        mathMulManualStep = Math.max(0, Math.floor(nextStep));
        stopMathMulAnimation();
        updateMathVisualizer();
      });

      renderer.domElement.addEventListener("pointerdown", onVizPointerDown);
      renderer.domElement.addEventListener("pointermove", onVizPointerMove);
      renderer.domElement.addEventListener("pointerup", onVizPointerUp);
      renderer.domElement.addEventListener("pointercancel", onVizPointerUp);

      function onResize() {
        const nextAspect = window.innerWidth / window.innerHeight;
        camera3D.aspect = nextAspect;
        camera3D.updateProjectionMatrix();

        camera2D.left = (-frustumSize * nextAspect) / 2;
        camera2D.right = (frustumSize * nextAspect) / 2;
        camera2D.top = frustumSize / 2;
        camera2D.bottom = -frustumSize / 2;
        camera2D.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
        updateVizHandleLabels();
        updateWorldAxisLabels();
        updatePointWorldViz();
      }
      window.addEventListener("resize", onResize);

      function animate() {
        if (interpolation) {
          const elapsed = performance.now() - interpolation.startTime;
          const rawT = Math.min(1, elapsed / interpolation.durationMs);
          if (Array.isArray(interpolation.keyframes) && interpolation.keyframes.length > 1) {
            const frames = interpolation.keyframes;
            const segments = frames.length - 1;
            const global = rawT * segments;
            const idx = Math.min(segments - 1, Math.floor(global));
            const localT = Math.min(1, Math.max(0, global - idx));
            const easedLocal = getEasedT(localT);
            applyInterpolatedMatrix(frames[idx], frames[idx + 1], easedLocal);
          } else {
            const easedT = getEasedT(rawT);
            applyInterpolatedMatrix(interpolation.startMatrix, interpolation.endMatrix, easedT);
          }
          if (rawT >= 1) {
            completeInterpolationNow();
          }
        }
        if (mathMulAnimation) {
          const frame = getMathMulAnimationFrame();
          if (frame) {
            mathMulManualStep = frame.stepIndex;
            if (frame.done) {
              stopMathMulAnimation();
              updateMathVisualizer();
            } else if (frame.stepIndex !== mathMulLastRenderedStep) {
              mathMulLastRenderedStep = frame.stepIndex;
              updateMathVisualizer();
            }
          }
        }
        if (interpolation && toolMode === "transform") {
          renderTranslationViz();
        }
        controls.update();
        updateVizHandleLabels();
        updateWorldAxisLabels();
        updatePointWorldViz();
        renderer.render(scene, activeCamera);
        requestAnimationFrame(animate);
      }

      animate();
    </script>
  </body>
</html>

